<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VuePress</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/syan/logo.png">
    <meta name="description" content="Syan的文档">
    
    <link rel="preload" href="/syan/assets/css/0.styles.3b3c9b2f.css" as="style"><link rel="preload" href="/syan/assets/js/app.f78fc011.js" as="script"><link rel="preload" href="/syan/assets/js/2.284a2749.js" as="script"><link rel="preload" href="/syan/assets/js/10.d767531b.js" as="script"><link rel="prefetch" href="/syan/assets/js/11.3190c8a4.js"><link rel="prefetch" href="/syan/assets/js/12.cb80c00e.js"><link rel="prefetch" href="/syan/assets/js/13.118edb13.js"><link rel="prefetch" href="/syan/assets/js/14.66a8557e.js"><link rel="prefetch" href="/syan/assets/js/15.daf5eb87.js"><link rel="prefetch" href="/syan/assets/js/16.a81e5f62.js"><link rel="prefetch" href="/syan/assets/js/17.4b1c06c6.js"><link rel="prefetch" href="/syan/assets/js/18.7e676734.js"><link rel="prefetch" href="/syan/assets/js/19.0538ca1a.js"><link rel="prefetch" href="/syan/assets/js/20.674152e4.js"><link rel="prefetch" href="/syan/assets/js/21.6f7f2255.js"><link rel="prefetch" href="/syan/assets/js/22.520615a5.js"><link rel="prefetch" href="/syan/assets/js/3.f2393cf0.js"><link rel="prefetch" href="/syan/assets/js/4.64b343ca.js"><link rel="prefetch" href="/syan/assets/js/5.3b624bfb.js"><link rel="prefetch" href="/syan/assets/js/6.0f39b99e.js"><link rel="prefetch" href="/syan/assets/js/7.21edf774.js"><link rel="prefetch" href="/syan/assets/js/8.07d705eb.js"><link rel="prefetch" href="/syan/assets/js/9.d2598df9.js">
    <link rel="stylesheet" href="/syan/assets/css/0.styles.3b3c9b2f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/syan/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/syan/frontend/base/htm.html" class="sidebar-link">HTML</a></li><li><a href="/syan/frontend/base/css.html" class="sidebar-link">CSS</a></li><li><a href="/syan/frontend/base/js.html" class="sidebar-link">JS</a></li><li><a href="/syan/frontend/browser/" class="sidebar-link">浏览器</a></li><li><a href="/syan/frontend/http/" class="sidebar-link">HTTP/HTTPS</a></li><li><a href="/syan/frontend/base/interview.html" aria-current="page" class="active sidebar-link">面经</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>代码实现</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试记录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><a href="https://github.com/yisainan/web-interview/blob/master/content/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4.md" target="_blank" rel="noopener noreferrer">前端面试合集<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://github.com/a1029563229/InterviewQuestions" target="_blank" rel="noopener noreferrer">前端面试-吾日三省吾身<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://yuchengkai.cn/docs/frontend/framework.html#mvvm" target="_blank" rel="noopener noreferrer">前端小册-yck<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://jsgodroad.com/questions/" target="_blank" rel="noopener noreferrer">干爆前端-每日一题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://muyiy.cn/blog/7/7.2.html#%E5%8A%A0%E5%BC%BA%E7%89%88-throttle" target="_blank" rel="noopener noreferrer">木易杨前端进阶<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.jianshu.com/p/5a1cd768ac1e" target="_blank" rel="noopener noreferrer">HTTPS通信原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://mp.weixin.qq.com/s/ezOX9lcLEOuMjlRIrT_ARw" target="_blank" rel="noopener noreferrer">前端性能优化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h3> <h4 id="什么是事件循环机制"><a href="#什么是事件循环机制" class="header-anchor">#</a> 什么是事件循环机制？</h4> <p>首先，明确JS是单线程的，但是在JS中是可以处理异步任务的。</p> <p>其次，明确JS中的代码有宏任务和微任务之分，宏任务有<code>script</code>，DOM事件处理，XHR请求，setTimeout，setInterval；微任务有Promise，process.nextTick，MutationObserver。</p> <p>JS代码的执行，都是在JS主线程上的，在代码执行过程中，遇到宏任务和微任务时，会将任务加入到相应的任务队列，当主线程的代码执行完毕之后，会优先取出微任务队列中的任务去执行，执行完之后，宏任务队列一次推出一个执行，宏任务执行空隙一次性清空一整个微任务队列，如此循环。</p> <h4 id="关于对作用域的了解"><a href="#关于对作用域的了解" class="header-anchor">#</a> 关于对作用域的了解</h4> <blockquote><p>JS的作用域其实是词法作用域，也叫做静态作用域。是在JS解释阶段产生的。
JS作用域有全局作用域，函数作用域，块级作用域。</p></blockquote> <h4 id="对闭包的了解-闭包会引起什么问题-如何解决"><a href="#对闭包的了解-闭包会引起什么问题-如何解决" class="header-anchor">#</a> 对闭包的了解，闭包会引起什么问题，如何解决？</h4> <p>可以访问其他函数中的变量的函数。常见的形态：一个函数中，返回了另外一个函数，而在返回的这个函数中，可以访问到非函数作用域内的变量。</p> <p>会产生的问题：函数执行完后，函数内部的变量没有被释放，内存占用会变长</p> <p>解决：闭包函数执行完后，手动置为null，释放内存</p> <h4 id="js代码的执行过程"><a href="#js代码的执行过程" class="header-anchor">#</a> JS代码的执行过程</h4> <p>JS执行过程分为两个步骤：解释和执行。</p> <p>解释阶段：词法分析，语法分析，作用域确定
执行阶段：创建执行上下文，执行代码，垃圾回收</p> <h4 id="什么是跨域-如何解决"><a href="#什么是跨域-如何解决" class="header-anchor">#</a> 什么是跨域？如何解决？</h4> <p>浏览器的同源策略：浏览器约定，只有协议名，域名，端口号都一致的两个地址，才是同源的。</p> <p>跨域：不同源之间的请求，会导致跨域。</p> <p>跨域存在的意义：为了安全</p> <p>跨域解决方案：</p> <p>JSONP：</p> <ul><li>通过<code>script</code>标签</li> <li>只支持<code>get</code>接口</li> <li>访问地址后带上前端定义的callback</li> <li>需要后端配合</li> <li>不安全，可能会造成XSS攻击</li></ul> <p>CROS：</p> <ul><li>后端响应头添加上 <code>Access-Control-Allow-Origin</code></li> <li>CROS 跨域时，要区分简单请求和非简单请求，对于非简单请求，会先发送一个OPTIONS预检请求，告诉服务期请求方法和自定义请求头
<ul><li>简单请求：GET，HEAD，POST（contentType为<code>text/plain</code>,<code>multipart/form-data</code>,<code>application/x-www-form-urlencode</code>）</li></ul></li></ul> <p>postMessage：</p> <ul><li>两多个打开的页面之间相互传递消息</li></ul> <p>代理：</p> <p>WebSocket：</p> <blockquote><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。</p></blockquote> <p>document.domain：</p> <blockquote><p>只适用于二级域名一样的情况，主页面和iframe之间，document.domain = '一级域名'</p></blockquote> <h4 id="关于对原型链的了解"><a href="#关于对原型链的了解" class="header-anchor">#</a> 关于对原型链的了解</h4> <p>JS中所有函数都可以是构造函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'123'</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype

Person<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype

Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span>
</code></pre></div><h4 id="什么是高阶函数"><a href="#什么是高阶函数" class="header-anchor">#</a> 什么是高阶函数</h4> <p>在JS中，一个函数可以作为另一个函数的参数或返回值。</p> <h4 id="websocket"><a href="#websocket" class="header-anchor">#</a> websocket</h4> <p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。</p> <h4 id="promise-generator-async和await-作用及原理"><a href="#promise-generator-async和await-作用及原理" class="header-anchor">#</a> Promise, Generator, Async和await 作用及原理</h4> <p>异步解决方案：</p> <p>Promise</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 实现promise</span>
<span class="token comment">// const PENDING = 'pending'</span>
<span class="token comment">// const FULFILLED = 'fulfilled'</span>
<span class="token comment">// const REJECTED = 'rejected'</span>

<span class="token comment">// function resolvePromise() {</span>

<span class="token comment">// }</span>

<span class="token comment">// class MyPromise {</span>
<span class="token comment">//   constructor(fn) {</span>
<span class="token comment">//     if (typeof fn !== 'function') {</span>
<span class="token comment">//       throw new Error('MyPromise must accept a function as a parameter')</span>
<span class="token comment">//     }</span>

<span class="token comment">//     this.status = PENDING</span>
<span class="token comment">//     this.value = null</span>
<span class="token comment">//     this.fulfilledQueue = []</span>
<span class="token comment">//     this.rejectedQueue = []</span>

<span class="token comment">//     try {</span>
<span class="token comment">//       fn(this._resolve.bind(this), this._reject.bind(this))</span>
<span class="token comment">//     } catch (err) {</span>
<span class="token comment">//       this._reject(err)</span>
<span class="token comment">//     }</span>
<span class="token comment">//   }</span>

<span class="token comment">//   _resolve(value) {</span>
<span class="token comment">//     if (this.status === PENDING) {</span>
<span class="token comment">//       this.value = value</span>
<span class="token comment">//       this.status = RESOLVED</span>

<span class="token comment">//       this.fulfilledQueue.forEach(callback =&gt; {</span>
<span class="token comment">//         callback(this.value)</span>
<span class="token comment">//       })</span>
<span class="token comment">//     }</span>
<span class="token comment">//   }</span>

<span class="token comment">//   _reject(error) {</span>
<span class="token comment">//     if (this.status === PENDING) {</span>
<span class="token comment">//       this.value = error</span>
<span class="token comment">//       this.status = REJECTED</span>

<span class="token comment">//       this.rejectedQueue.forEach(callback =&gt; {</span>
<span class="token comment">//         callback(this.value)</span>
<span class="token comment">//       })</span>
<span class="token comment">//     }</span>
<span class="token comment">//   }</span>

<span class="token comment">//   then(onFulfilled, onRejected) {</span>
<span class="token comment">//     onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : () =&gt; {}</span>
<span class="token comment">//     onRejected = typeof onRejected === 'function' ? onRejected : () =&gt; {}</span>

<span class="token comment">//     const promise = new MyPromise((resolve, reject) =&gt; {</span>
<span class="token comment">//       if (this.status === PENDING) {</span>
<span class="token comment">//         this.fulfilledQueue.push()</span>
<span class="token comment">//       }</span>

<span class="token comment">//       if (this.status === FULFILLED) {</span>
        
<span class="token comment">//       }</span>

<span class="token comment">//       if (this.status === REJECTED) {</span>

<span class="token comment">//       }</span>
<span class="token comment">//     })</span>

<span class="token comment">//     return promise</span>
<span class="token comment">//   }</span>

<span class="token comment">//   catch() {}</span>
<span class="token comment">// }</span>
</code></pre></div><h4 id="重排重绘机制-浏览器重排重绘是-css-样式改变了就马上更新吗"><a href="#重排重绘机制-浏览器重排重绘是-css-样式改变了就马上更新吗" class="header-anchor">#</a> 重排重绘机制, 浏览器重排重绘是 css 样式改变了就马上更新吗</h4> <p>重排：改变了dom的大小，位置，影响到布局，resize</p> <p>重绘：只改变了dom的颜色，背景，不影响布局</p> <p>浏览器是60hz的刷新率，即 1000 / 60 = 16.6，所以是16.6ms更新一次</p> <h4 id="从url输入到页面展示-经历了什么"><a href="#从url输入到页面展示-经历了什么" class="header-anchor">#</a> 从url输入到页面展示，经历了什么？</h4> <ul><li>DNS解析：</li> <li>HTTP 下载资源</li> <li>解析DOM，CSSOM，render Object</li></ul> <h4 id="前端攻击-如何模拟一个csrf-攻击"><a href="#前端攻击-如何模拟一个csrf-攻击" class="header-anchor">#</a> 前端攻击, 如何模拟一个CSRF 攻击</h4> <ul><li>XSS</li> <li>CSRF</li></ul> <h4 id="前端加密有哪些"><a href="#前端加密有哪些" class="header-anchor">#</a> 前端加密有哪些</h4> <h4 id="http-1-x-2-x-3-x-区别"><a href="#http-1-x-2-x-3-x-区别" class="header-anchor">#</a> http 1.x 2.x 3.x 区别</h4> <h4 id="浏览器缓存过程是怎么样的-属性有哪些"><a href="#浏览器缓存过程是怎么样的-属性有哪些" class="header-anchor">#</a> 浏览器缓存过程是怎么样的, 属性有哪些</h4> <ul><li>强缓存：Expires，Cache-Control</li> <li>协商缓存：Last-Modified / IF-Modified-Since，ETag / IF-None-Match</li></ul> <h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="header-anchor">#</a> 垃圾回收机制</h4> <ul><li>标记清除</li> <li>引用计数</li></ul> <h4 id="深拷贝的实现-如何避免循环引用"><a href="#深拷贝的实现-如何避免循环引用" class="header-anchor">#</a> 深拷贝的实现？如何避免循环引用？</h4> <h3 id="webpack"><a href="#webpack" class="header-anchor">#</a> Webpack</h3> <h4 id="loader-和-plugin-的不同"><a href="#loader-和-plugin-的不同" class="header-anchor">#</a> Loader 和 Plugin 的不同</h4> <h4 id="_3-x-4-x-和-5-x-有哪些区别"><a href="#_3-x-4-x-和-5-x-有哪些区别" class="header-anchor">#</a> 3.x , 4.x 和 5.x 有哪些区别</h4> <h4 id="用过哪些loader-和-plugin"><a href="#用过哪些loader-和-plugin" class="header-anchor">#</a> 用过哪些loader 和 Plugin</h4> <p>1.Webpack 的工作过程
校验配置文件 ：读取命令行传入或者webpack.config.js文件，初始化本次构建的配置参数
生成Compiler对象：执行配置文件中的插件实例化语句new MyWebpackPlugin()，为webpack事件流挂上自定义hooks
进入entryOption阶段：webpack开始读取配置的Entries，递归遍历所有的入口文件
run/watch：如果运行在watch模式则执行watch方法，否则执行run方法
compilation：创建Compilation对象回调compilation相关钩子，依次进入每一个入口文件(entry)，使用loader对文件进行编译。通过compilation我可以可以读取到module的resource（资源路径）、loaders（使用的loader）等信息。再将编译好的文件内容使用acorn解析生成AST静态语法树。然后递归、重复的执行这个过程， 所有模块和和依赖分析完成后，执行 compilation 的 seal 方法对每个 chunk 进行整理、优化、封装__webpack_require__来模拟模块化操作.
emit：所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的compilation.assets上拿到所需数据，其中包括即将输出的资源、代码块Chunk等等信息。
2.热更新原理
3.项目有没配置过Webpack的优化
4.loader 的工作原理: 本质就是一个个的函数，在模块的编译阶段，会使用这些loader对源代码进行处理，处理时，一般都会生成AST解析树，这样可以方便处理
5.plugin 的工作原理:
读取配置的过程中会先执行 new HelloPlugin(options) 初始化一个 HelloPlugin 获得其实例。
初始化 compiler 对象后调用 HelloPlugin.apply(compiler) 给插件实例传入 compiler 对象。
插件实例在获取到 compiler 对象后，就可以通过compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack
6.vite 是什么, 和Webpack有什么区别</p> <h3 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h3> <h4 id="vue-2-x-组件通讯的方式-14种"><a href="#vue-2-x-组件通讯的方式-14种" class="header-anchor">#</a> Vue 2.X 组件通讯的方式(14种)</h4> <h4 id="vue-router-钩子有哪些"><a href="#vue-router-钩子有哪些" class="header-anchor">#</a> Vue-router 钩子有哪些</h4> <h4 id="指令钩子有哪些"><a href="#指令钩子有哪些" class="header-anchor">#</a> 指令钩子有哪些</h4> <h4 id="watch和computed区别"><a href="#watch和computed区别" class="header-anchor">#</a> watch和computed区别</h4> <h4 id="渲染列表的时候为什么要使用key"><a href="#渲染列表的时候为什么要使用key" class="header-anchor">#</a> 渲染列表的时候为什么要使用key</h4> <h4 id="父子组件之间的生命周期执行顺序"><a href="#父子组件之间的生命周期执行顺序" class="header-anchor">#</a> 父子组件之间的生命周期执行顺序</h4> <p>父beforeCreate，父created，子beforeCreate，子created，子beforeMount，子mounted，父beforeMount，父mounted</p> <h4 id="简单介绍下插槽"><a href="#简单介绍下插槽" class="header-anchor">#</a> 简单介绍下插槽</h4> <p>插槽就是vue组件中预留的一部分内容，由外部外传入进来
指令插槽，作用域插槽</p> <h4 id="什么是路由懒加载"><a href="#什么是路由懒加载" class="header-anchor">#</a> 什么是路由懒加载</h4> <p>声明路由时，component的可以是对应一个组件，也可以是一个函数，这个的返回值，是通过require，resolve，import的方式动态加载组件
作用：是什么？</p> <h4 id="route和router的区别"><a href="#route和router的区别" class="header-anchor">#</a> route和router的区别</h4> <p>Router是整个项目的路由对象，route是每个页面的路由实例</p> <h4 id="vuex中的action和mutation有什么区别"><a href="#vuex中的action和mutation有什么区别" class="header-anchor">#</a> vuex中的action和mutation有什么区别</h4> <p>mutation 是纯函数，接收state，返回state
Action 主要用来做异步操作，然后有结果后再更新mutation</p> <h4 id="vue创建组件的时候data设计为函数形式"><a href="#vue创建组件的时候data设计为函数形式" class="header-anchor">#</a> vue创建组件的时候data设计为函数形式</h4> <p>如果data是对象，且有多个组件实例，组件实例中改变了data数据，会影响到其他组件实例的data数据</p> <h4 id="vue-的双向数据绑定原理"><a href="#vue-的双向数据绑定原理" class="header-anchor">#</a> vue 的双向数据绑定原理</h4> <p>大头头大</p> <h4 id="页面刷新后vuex中的state数据丢失会怎么解决"><a href="#页面刷新后vuex中的state数据丢失会怎么解决" class="header-anchor">#</a> 页面刷新后vuex中的state数据丢失会怎么解决</h4> <p>Vue 2.x 源码编译的过程
Vue 的diff 过程
虚拟dom实现原理，为什么要引入虚拟dom？
Vue 的 nextTick 原理
Vue 的set 原理
Vue-router 的实现原理和缓存策略
vue3新特性
四、React
react 单向数据过程
react与vue的异同
react新定义的有哪些生命周期
react16 的 fiber 理解
redux工作流程
redux 为什么要把 reducer 设计成纯函数
react 的diff 过程
什么是高阶组件，如何设计一个高阶组件？</p> <h3 id="react"><a href="#react" class="header-anchor">#</a> React</h3> <h4 id="setstate是同步还是异步-什么时候表现同步-什么时候表现异步"><a href="#setstate是同步还是异步-什么时候表现同步-什么时候表现异步" class="header-anchor">#</a> setState是同步还是异步？什么时候表现同步，什么时候表现异步？</h4> <p>好像是生命周期内是异步的，生命周期外是同步的</p> <h4 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="header-anchor">#</a> 受控组件和非受控组件</h4> <p>受控组件：组件中会改变数据，如表单相关的组件
非受控组件：组件是纯显示组件，组件的改变都是由外部数据决定的</p> <h4 id="组件通讯方式-13种"><a href="#组件通讯方式-13种" class="header-anchor">#</a> 组件通讯方式(13种)</h4> <h4 id="decorator-用过没得-作用是啥"><a href="#decorator-用过没得-作用是啥" class="header-anchor">#</a> Decorator 用过没得, 作用是啥</h4> <p>注解</p> <h4 id="redux的理解"><a href="#redux的理解" class="header-anchor">#</a> redux的理解</h4> <h4 id="reducer为什么设计成一个纯函数"><a href="#reducer为什么设计成一个纯函数" class="header-anchor">#</a> reducer为什么设计成一个纯函数</h4> <h4 id="react常用的hooks有哪些"><a href="#react常用的hooks有哪些" class="header-anchor">#</a> react常用的hooks有哪些</h4> <p>useState, useEffect, useCallback, useMemo, …</p> <h4 id="usememo与useeffect的差别"><a href="#usememo与useeffect的差别" class="header-anchor">#</a> useMemo与useEffect的差别</h4> <p>useMomo 和 useCallback 的差别?</p> <h4 id="hooks是哪个版本出现的-解决了什么问题"><a href="#hooks是哪个版本出现的-解决了什么问题" class="header-anchor">#</a> hooks是哪个版本出现的, 解决了什么问题</h4> <p>16.8</p> <h3 id="typescript"><a href="#typescript" class="header-anchor">#</a> TypeScript</h3> <h4 id="_1-作用"><a href="#_1-作用" class="header-anchor">#</a> 1.作用</h4> <p>Ts是js的超集，主要是在js的基础上，添加了类型限制</p> <h4 id="用过ts哪些功能"><a href="#用过ts哪些功能" class="header-anchor">#</a> 用过TS哪些功能</h4> <p>参数类型，返回值类型，装饰器，interface</p> <h4 id="ts-有哪些内置类型-比js多了void"><a href="#ts-有哪些内置类型-比js多了void" class="header-anchor">#</a> TS 有哪些内置类型, 比JS多了Void</h4> <h4 id="ts的-接口-和-type-语句有什么区别"><a href="#ts的-接口-和-type-语句有什么区别" class="header-anchor">#</a> TS的“接口”和“type”语句有什么区别？</h4> <h4 id="typescript中的装饰器作用"><a href="#typescript中的装饰器作用" class="header-anchor">#</a> TypeScript中的装饰器作用</h4> <h4 id="如何检查typescript中的null和undefined"><a href="#如何检查typescript中的null和undefined" class="header-anchor">#</a> 如何检查TypeScript中的null和undefined</h4> <h4 id="typescript中的泛型作用"><a href="#typescript中的泛型作用" class="header-anchor">#</a> TypeScript中的泛型作用</h4> <h4 id="什么叫函数重载-ts-有函数重载吗"><a href="#什么叫函数重载-ts-有函数重载吗" class="header-anchor">#</a> 什么叫函数重载, TS 有函数重载吗</h4> <h4 id="ts-如何在函数中支持可选参数的"><a href="#ts-如何在函数中支持可选参数的" class="header-anchor">#</a> TS 如何在函数中支持可选参数的</h4> <h3 id="编程"><a href="#编程" class="header-anchor">#</a> 编程</h3> <h4 id="位运算实现两个变量相加"><a href="#位运算实现两个变量相加" class="header-anchor">#</a> 位运算实现两个变量相加</h4> <h4 id="实现数组的map方法"><a href="#实现数组的map方法" class="header-anchor">#</a> 实现数组的map方法</h4> <h4 id="实现对象数组的去重"><a href="#实现对象数组的去重" class="header-anchor">#</a> 实现对象数组的去重</h4> <h3 id="node"><a href="#node" class="header-anchor">#</a> Node</h3> <h4 id="用过node-哪些功能"><a href="#用过node-哪些功能" class="header-anchor">#</a> 用过Node 哪些功能</h4> <h4 id="npm和node-的关系"><a href="#npm和node-的关系" class="header-anchor">#</a> Npm和Node 的关系</h4> <h3 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h3> <p>观察者模式
发布者订阅模式
工厂模式
单例模式
适配器模式
策略模式
中介者模式</p> <p>六  编程
实现eventEmmiter类
（柯里化函数）实现add函数，满足add(1)(2, 3)计算
实现两个大数相加
实现节流函数和防抖函数
实现promise.all、promise.race
项目中用过哪些设计模式
如何优化项目</p> <p>七、Node</p> <ol><li>require的模块查找规则:
每个模块里面的exports, require, module, __filename, __dirname五个参数都不是全局变量，而是模块加载的时候注入的。
为了注入这几个变量，我们需要将用户的代码用一个函数包裹起来，拼一个字符串然后调用沙盒模块vm来实现。
初始状态下，模块里面的this, exports, module.exports都指向同一个对象，如果你对他们重新赋值，这种连接就断了。
对module.exports的重新赋值会作为模块的导出内容，但是你对exports的重新赋值并不能改变模块导出内容，只是改变了exports这个变量而已，因为模块始终是module，导出内容是module.exports。
为了解决循环引用，模块在加载前就会被加入缓存，下次再加载会直接返回缓存，如果这时候模块还没加载完，你可能拿到未完成的exports。
2.node 事件循环和浏览器的区别
3.node 中怎么加载 HTML文件
4.node 怎么解决跨域
5.koa 原理
6.node 怎么创建线程, 线程怎么通讯
7.module.exports与exports的区别
8.require和import有什么区别, 加载上有什么区别
9.sql 语句有了解吗
10.npm提供了哪些钩子？各有什么作用
11.mySql 和 mongonDB 区别</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/syan/frontend/http/" class="prev">
        HTTP/HTTPS
      </a></span> <span class="next"><a href="/syan/frontend/framework/">
        基本概念
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/syan/assets/js/app.f78fc011.js" defer></script><script src="/syan/assets/js/2.284a2749.js" defer></script><script src="/syan/assets/js/10.d767531b.js" defer></script>
  </body>
</html>
