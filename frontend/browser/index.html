<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件机制</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/syan/logo.png">
    <meta name="description" content="Syan的文档">
    
    <link rel="preload" href="/syan/assets/css/0.styles.3b3c9b2f.css" as="style"><link rel="preload" href="/syan/assets/js/app.f78fc011.js" as="script"><link rel="preload" href="/syan/assets/js/2.284a2749.js" as="script"><link rel="preload" href="/syan/assets/js/12.cb80c00e.js" as="script"><link rel="prefetch" href="/syan/assets/js/10.d767531b.js"><link rel="prefetch" href="/syan/assets/js/11.3190c8a4.js"><link rel="prefetch" href="/syan/assets/js/13.118edb13.js"><link rel="prefetch" href="/syan/assets/js/14.66a8557e.js"><link rel="prefetch" href="/syan/assets/js/15.daf5eb87.js"><link rel="prefetch" href="/syan/assets/js/16.a81e5f62.js"><link rel="prefetch" href="/syan/assets/js/17.4b1c06c6.js"><link rel="prefetch" href="/syan/assets/js/18.7e676734.js"><link rel="prefetch" href="/syan/assets/js/19.0538ca1a.js"><link rel="prefetch" href="/syan/assets/js/20.674152e4.js"><link rel="prefetch" href="/syan/assets/js/21.6f7f2255.js"><link rel="prefetch" href="/syan/assets/js/22.520615a5.js"><link rel="prefetch" href="/syan/assets/js/3.f2393cf0.js"><link rel="prefetch" href="/syan/assets/js/4.64b343ca.js"><link rel="prefetch" href="/syan/assets/js/5.3b624bfb.js"><link rel="prefetch" href="/syan/assets/js/6.0f39b99e.js"><link rel="prefetch" href="/syan/assets/js/7.21edf774.js"><link rel="prefetch" href="/syan/assets/js/8.07d705eb.js"><link rel="prefetch" href="/syan/assets/js/9.d2598df9.js">
    <link rel="stylesheet" href="/syan/assets/css/0.styles.3b3c9b2f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/syan/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/syan/frontend/base/htm.html" class="sidebar-link">HTML</a></li><li><a href="/syan/frontend/base/css.html" class="sidebar-link">CSS</a></li><li><a href="/syan/frontend/base/js.html" class="sidebar-link">JS</a></li><li><a href="/syan/frontend/browser/" aria-current="page" class="active sidebar-link">浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#事件机制" class="sidebar-link">事件机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#事件触发的三个阶段" class="sidebar-link">事件触发的三个阶段</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#事件注册" class="sidebar-link">事件注册</a></li></ul></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#事件委托" class="sidebar-link">事件委托</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#跨域" class="sidebar-link">跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#jsonp" class="sidebar-link">JSONP</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#cros-坑还有很多" class="sidebar-link">CROS（坑还有很多）</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#document-domain" class="sidebar-link">document.domain</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#postmessage" class="sidebar-link">postMessage</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#websocket" class="sidebar-link">webSocket</a></li></ul></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#事件循环" class="sidebar-link">事件循环</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#浏览器中的事件循环" class="sidebar-link">浏览器中的事件循环</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#node-中的事件循环" class="sidebar-link">node 中的事件循环</a></li></ul></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#浏览器存储" class="sidebar-link">浏览器存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#存储分类" class="sidebar-link">存储分类</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#cookie相关属性" class="sidebar-link">cookie相关属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#service-worker" class="sidebar-link">service worker</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#浏览器渲染机制" class="sidebar-link">浏览器渲染机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#load和domcontentloaded的区别" class="sidebar-link">Load和DOMContentLoaded 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#性能" class="sidebar-link">性能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#dns解析-dns预解析" class="sidebar-link">DNS解析，DNS预解析</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#预加载-预取-预渲染" class="sidebar-link">预加载，预取，预渲染</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#懒加载" class="sidebar-link">懒加载</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#缓存" class="sidebar-link">缓存</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#图片资源的优化点" class="sidebar-link">图片资源的优化点</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#前端代码的优化点" class="sidebar-link">前端代码的优化点</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#webpack中的优化点" class="sidebar-link">webpack中的优化点</a></li><li class="sidebar-sub-header"><a href="/syan/frontend/browser/#如何渲染几万条数据并不卡住界面" class="sidebar-link">如何渲染几万条数据并不卡住界面？？</a></li></ul></li></ul></li><li><a href="/syan/frontend/http/" class="sidebar-link">HTTP/HTTPS</a></li><li><a href="/syan/frontend/base/interview.html" class="sidebar-link">面经</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>代码实现</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试记录</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="事件机制"><a href="#事件机制" class="header-anchor">#</a> 事件机制</h2> <h3 id="事件触发的三个阶段"><a href="#事件触发的三个阶段" class="header-anchor">#</a> 事件触发的三个阶段</h3> <blockquote><p>事件分三个阶段</p></blockquote> <ul><li>捕获: 事件从<code>根节点</code>向注册节点传播</li> <li>触发：事件到达注册节点，触发</li> <li>冒泡：事件由注册节点向根节点传播</li></ul> <blockquote><p>常规浏览器的事件触发顺序依次是：捕获-&gt;触发-&gt;冒泡，事件默认是在冒泡阶段触发
IE 浏览器</p></blockquote> <h3 id="事件注册"><a href="#事件注册" class="header-anchor">#</a> 事件注册</h3> <ul><li><p><code>addEventListener</code>，该方法有三个参数：事件名，事件方法，事件配置。其中事件配置可以是一个<code>bool</code>，也可以是一个对象，配置项是<code>bool</code>值的时候，指的是事件是否在捕获阶段触发，默认是<code>false</code>。配置项是对象时，包含以下几个参数：capture：是否在捕获阶段触发；once：是否只触发一次；passive：表示永远不调用preventDefault。</p></li> <li><p><code>stopPropagation</code> 阻止事件冒泡</p></li> <li><p><code>stopImmediatePropagation</code> 阻止事件目标其他的事件（多事件的情况下）。</p></li></ul> <h2 id="事件委托"><a href="#事件委托" class="header-anchor">#</a> 事件委托</h2> <blockquote><p>有多个兄弟元素需要绑定事件时，我们为了减少事件注册，可以将事件注册在它们的父元素上，这种场景称之为事件委托。</p></blockquote> <ul><li><code>event.target</code>：指的是触发事件的元素</li> <li><code>event.currentTarget</code>：指的是绑定事件的元素</li></ul> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <ul><li>跨域是因为浏览器出于安全考虑，而设计的同源策略产生的。浏览器同源策略：两个地址只有<code>协议名</code>，<code>域名</code>，<code>端口</code>都一致时，才是同源；否则HTTP请求就会产生跨域。</li></ul> <p>可以考虑以下几种跨域方案：</p> <h3 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h3> <p>特点：</p> <ul><li>使用 <code>script</code> 标签</li> <li>只支持get请求</li> <li>需要服务端配合</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> jsonpCallback<span class="token punctuation">,</span> success</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url
  script<span class="token punctuation">.</span>async <span class="token operator">=</span> <span class="token boolean">true</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span>
  window<span class="token punctuation">[</span>jsonpCallback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    success <span class="token operator">&amp;&amp;</span> <span class="token function">success</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token string">'http://xxx'</span><span class="token punctuation">,</span> <span class="token string">'callback'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="cros-坑还有很多"><a href="#cros-坑还有很多" class="header-anchor">#</a> CROS（坑还有很多）</h3> <ul><li>需要浏览器和服务端同时支持</li> <li>服务端通过给响应头设置<code>Access-Control-Allow-Origin</code>字段</li></ul> <h3 id="document-domain"><a href="#document-domain" class="header-anchor">#</a> document.domain</h3> <p>如果两个页面的二级域名是一样的，则可以设置页面的<code>document.domain</code>为二级域名，则这两个页面就可以相互通讯。</p> <p>示例如下：<code>a.test.com</code>和<code>b.test.com</code></p> <h3 id="postmessage"><a href="#postmessage" class="header-anchor">#</a> postMessage</h3> <p>这种方式只支持两个页面嵌套时使用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 发送消息端</span>
window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span>
<span class="token comment">// 接收消息端</span>
<span class="token keyword">var</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin <span class="token operator">||</span> event<span class="token punctuation">.</span>originalEvent<span class="token punctuation">.</span>origin
  <span class="token keyword">if</span> <span class="token punctuation">(</span>origin <span class="token operator">===</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'验证通过'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="websocket"><a href="#websocket" class="header-anchor">#</a> webSocket</h3> <h2 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h2> <h3 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="header-anchor">#</a> 浏览器中的事件循环</h3> <p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。</p> <p>JS虽然是单线程的，但是浏览器是多线程的。浏览器中除了JS主线程，还有http请求线程，定时器触发线程，事件触发线程，页面渲染线程。</p> <p>JS代码在执行时，遇到异步任务，就将该任务加到对应的任务队列中。当主线程执行完毕，执行栈没有任务时，就从任务队列中取出任务，放到执行栈取执行。</p> <p>不同的异步任务可以大致分为宏任务和微任务：</p> <p>宏任务：</p> <ul><li><code>&lt;script&gt;</code>标签的加载</li> <li>setTimeout / setInterval</li> <li>UI render</li> <li>setImmediate（node：在这次执行队列执行完后，再执行）</li> <li>I/O</li></ul> <p>微任务：</p> <ul><li>promise</li> <li>MutationObserver（监听DOM的改变）</li> <li>process.nextTick（node：当前执行栈执行完后，立即执行）</li></ul> <h3 id="node-中的事件循环"><a href="#node-中的事件循环" class="header-anchor">#</a> node 中的事件循环</h3> <h2 id="浏览器存储"><a href="#浏览器存储" class="header-anchor">#</a> 浏览器存储</h2> <h3 id="存储分类"><a href="#存储分类" class="header-anchor">#</a> 存储分类</h3> <table><thead><tr><th>类型</th> <th>存储限制</th> <th>特点</th></tr></thead> <tbody><tr><td>localStorage</td> <td>5M</td> <td>本地存储，长期有效</td></tr> <tr><td>sessionStorage</td> <td>5M</td> <td>本地存储，当前会话有效</td></tr> <tr><td>cookie</td> <td>4K</td> <td>本地存储，有过期时间（有些浏览器，可能会定时清除），会随请求被携带到服务端</td></tr> <tr><td>indexDB</td> <td>无限制</td> <td>本地存储，长期有效</td></tr></tbody></table> <h3 id="cookie相关属性"><a href="#cookie相关属性" class="header-anchor">#</a> cookie相关属性</h3> <table><thead><tr><th>属性</th> <th>作用</th></tr></thead> <tbody><tr><td>value</td> <td>如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr> <tr><td>http-only</td> <td>不允许JS读取cookie，减少XSS攻击</td></tr> <tr><td>secure</td> <td>HTTPS下才会携带</td></tr> <tr><td>same-site</td> <td>不允许跨域携带cookie，减少CSRF攻击</td></tr></tbody></table> <h2 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> service worker</h2> <p><code>service worker</code>是浏览器开起一个独立于主线程的线程，充当浏览器和服务器之间的代理。可以拦截所有请求，如果存在缓存则优先使用缓存，如果没有则请求接口；并且由于是独立的线程，所以<code>service worker</code>可以做复杂计算的工作，不会阻塞主线程。</p> <p>PWA主要用了<code>service worker</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// index.js</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  navigator<span class="token punctuation">.</span>serviceWorker
    <span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'sw.js'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">registration</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'service worker 注册成功'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'servcie worker 注册失败'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// sw.js</span>
<span class="token comment">// 监听 `install` 事件，回调中缓存所需文件</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'my-cache'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./index.html'</span><span class="token punctuation">,</span> <span class="token string">'./index.js'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 拦截所有请求事件</span>
<span class="token comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> response
      <span class="token punctuation">}</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fetch source'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="header-anchor">#</a> 浏览器渲染机制</h2> <p>页面渲染的步骤，自上而下加载</p> <p>1、解析HTML，生成DOM树
2、解析CSS，生成CSSOM树
3、组合DOM树和CSSOM树，生成render树
4、根据render树布局，渲染页面</p> <ul><li>页面遇到外部css时，会阻塞CSSOM树的生成</li> <li>页面遇到JS代码时，会阻塞DOM树的构建</li></ul> <p><code>&lt;script&gt;</code>标签的 <code>async</code>，<code>defer</code>属性的作用：</p> <ul><li><code>async</code>：异步下载，下载完成后就执行</li> <li><code>defer</code>：新开线程下载，HTML解析完成后再执行</li></ul> <h3 id="load和domcontentloaded的区别"><a href="#load和domcontentloaded的区别" class="header-anchor">#</a> <code>Load</code>和<code>DOMContentLoaded</code>的区别</h3> <ul><li><code>Load</code>：页面资源都加载完毕时触发</li> <li><code>DOMContentLoaded</code>：HTML被加载解析完毕时触发</li></ul> <h2 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h2> <h3 id="dns解析-dns预解析"><a href="#dns解析-dns预解析" class="header-anchor">#</a> DNS解析，DNS预解析</h3> <ul><li><p>DNS解析：</p> <ul><li>查询浏览器DNS缓存</li> <li>查询本机DNS缓存</li> <li>查询本地DNS服务器</li> <li>查询根域名服务器</li> <li>查询顶级域名服务器</li> <li>返回结果</li></ul></li> <li><p>DNS预解析：</p></li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span>  <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>x-dns-prefetch-control<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>on<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span>  <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//www.zhix.net<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span>  <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//api.share.zhix.net<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span>  <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//bdimg.share.zhix.net<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="预加载-预取-预渲染"><a href="#预加载-预取-预渲染" class="header-anchor">#</a> 预加载，预取，预渲染</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>www.baidu.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>www.baidu.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prerender<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><ul><li>preload：提高加载当前页面指定资源的优先级。</li> <li>prefetch：A页面可能会打开B页面，可以在空闲情况下，预取B页面的内容存在内存中。</li> <li>prerender：可以通过预渲染将下载的文件预先在后台渲染。</li></ul> <h3 id="懒加载"><a href="#懒加载" class="header-anchor">#</a> 懒加载</h3> <ul><li>常用场景：图片长列表，一般在元素滚动到可视窗口的时候再加载，节省带宽。（如：vue中常用的v-lazy）</li></ul> <h3 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h3> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h4> <p>强缓存是查看缓存设置时间，只要在有效期内，就使用缓存，不会调用接口。</p> <p>强缓存的控制字段如下：</p> <ul><li>HTTP 1.0：<code>Expires</code>，过期日期时间<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code>，该字段会因本地时间改变而变化</li> <li>HTTP 1.1：<code>Cache-Control</code>，设置<code>Cache-control: max-age=30</code></li> <li>强缓存在缓存有效期间，不会请求后台</li></ul> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <p>协商缓存是向后台发起确认，如果资源没有被修改过，则会使用本地缓存</p> <p>协商缓存控制字段如下：</p> <ul><li><code>Last-Modified</code>和<code>If-Modified-Since</code></li></ul> <blockquote><p><code>Last-Modified</code> 是服务端静态资源最后改变的时间，前端请求时，服务端会将该数据返回到前端，前端后面请求时，<code>If-Modified-Since</code>会带上这个值，如果后端资源时间改变，就返回新资源，否则使用缓存。</p></blockquote> <ul><li><code>ETag</code>和<code>If-None-Match</code></li></ul> <blockquote><p>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</p></blockquote> <h4 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="header-anchor">#</a> 选择合适的缓存策略</h4> <p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p> <ul><li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li> <li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li> <li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul> <h3 id="图片资源的优化点"><a href="#图片资源的优化点" class="header-anchor">#</a> 图片资源的优化点</h3> <ul><li>字体图标使用svg，部分样式能使用CSS，就不用图片</li> <li>小图使用base64</li> <li>小图，改动小的情况下，可以使用雪碧图</li> <li>大图能使用webp尽量使用webp</li> <li>上传图片时，按需裁剪</li> <li>移动端部分列表显示的是小图，可以使用万象优图，裁剪图片</li></ul> <h3 id="前端代码的优化点"><a href="#前端代码的优化点" class="header-anchor">#</a> 前端代码的优化点</h3> <ul><li>CSS文件放在head中，CSS代码注意层级，层级不要过深</li> <li>前端打包代码压缩</li> <li>服务端开启压缩功能</li> <li><code>&lt;script&gt;</code>标签放在<code>body</code>下面</li> <li>复杂的JS逻辑计算，放在<code>WebWorker</code>中</li> <li>静态资源尽量使用CDN加载</li></ul> <h3 id="webpack中的优化点"><a href="#webpack中的优化点" class="header-anchor">#</a> webpack中的优化点</h3> <ul><li>生产环境使用<code>production</code>模式，会自动压缩代码</li> <li>优化图片，小图使用base64（image-loader）</li> <li>前端路由按需加载</li> <li>打包后的文件hash处理，使用浏览器缓存</li></ul> <h3 id="如何渲染几万条数据并不卡住界面"><a href="#如何渲染几万条数据并不卡住界面" class="header-anchor">#</a> 如何渲染几万条数据并不卡住界面？？</h3> <p>使用<code>requestAnimationFrame</code>分批渲染DOM</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/syan/frontend/base/js.html" class="prev">
        JS
      </a></span> <span class="next"><a href="/syan/frontend/http/">
        HTTP/HTTPS
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/syan/assets/js/app.f78fc011.js" defer></script><script src="/syan/assets/js/2.284a2749.js" defer></script><script src="/syan/assets/js/12.cb80c00e.js" defer></script>
  </body>
</html>
