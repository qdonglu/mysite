(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{360:function(t,a,e){"use strict";e.r(a);var s=e(42),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[e("a",{attrs:{href:"https://github.com/yisainan/web-interview/blob/master/content/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端面试合集"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/a1029563229/InterviewQuestions",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端面试-吾日三省吾身"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://yuchengkai.cn/docs/frontend/framework.html#mvvm",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端小册-yck"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://jsgodroad.com/questions/",target:"_blank",rel:"noopener noreferrer"}},[t._v("干爆前端-每日一题"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://muyiy.cn/blog/7/7.2.html#%E5%8A%A0%E5%BC%BA%E7%89%88-throttle",target:"_blank",rel:"noopener noreferrer"}},[t._v("木易杨前端进阶"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/5a1cd768ac1e",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTPS通信原理"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/ezOX9lcLEOuMjlRIrT_ARw",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端性能优化"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"javascript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[t._v("#")]),t._v(" JavaScript")]),t._v(" "),e("h4",{attrs:{id:"什么是事件循环机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是事件循环机制"}},[t._v("#")]),t._v(" 什么是事件循环机制？")]),t._v(" "),e("p",[t._v("首先，明确JS是单线程的，但是在JS中是可以处理异步任务的。")]),t._v(" "),e("p",[t._v("其次，明确JS中的代码有宏任务和微任务之分，宏任务有"),e("code",[t._v("script")]),t._v("，DOM事件处理，XHR请求，setTimeout，setInterval；微任务有Promise，process.nextTick，MutationObserver。")]),t._v(" "),e("p",[t._v("JS代码的执行，都是在JS主线程上的，在代码执行过程中，遇到宏任务和微任务时，会将任务加入到相应的任务队列，当主线程的代码执行完毕之后，会优先取出微任务队列中的任务去执行，执行完之后，宏任务队列一次推出一个执行，宏任务执行空隙一次性清空一整个微任务队列，如此循环。")]),t._v(" "),e("h4",{attrs:{id:"关于对作用域的了解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于对作用域的了解"}},[t._v("#")]),t._v(" 关于对作用域的了解")]),t._v(" "),e("blockquote",[e("p",[t._v("JS的作用域其实是词法作用域，也叫做静态作用域。是在JS解释阶段产生的。\nJS作用域有全局作用域，函数作用域，块级作用域。")])]),t._v(" "),e("h4",{attrs:{id:"对闭包的了解-闭包会引起什么问题-如何解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对闭包的了解-闭包会引起什么问题-如何解决"}},[t._v("#")]),t._v(" 对闭包的了解，闭包会引起什么问题，如何解决？")]),t._v(" "),e("p",[t._v("可以访问其他函数中的变量的函数。常见的形态：一个函数中，返回了另外一个函数，而在返回的这个函数中，可以访问到非函数作用域内的变量。")]),t._v(" "),e("p",[t._v("会产生的问题：函数执行完后，函数内部的变量没有被释放，内存占用会变长")]),t._v(" "),e("p",[t._v("解决：闭包函数执行完后，手动置为null，释放内存")]),t._v(" "),e("h4",{attrs:{id:"js代码的执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js代码的执行过程"}},[t._v("#")]),t._v(" JS代码的执行过程")]),t._v(" "),e("p",[t._v("JS执行过程分为两个步骤：解释和执行。")]),t._v(" "),e("p",[t._v("解释阶段：词法分析，语法分析，作用域确定\n执行阶段：创建执行上下文，执行代码，垃圾回收")]),t._v(" "),e("h4",{attrs:{id:"什么是跨域-如何解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是跨域-如何解决"}},[t._v("#")]),t._v(" 什么是跨域？如何解决？")]),t._v(" "),e("p",[t._v("浏览器的同源策略：浏览器约定，只有协议名，域名，端口号都一致的两个地址，才是同源的。")]),t._v(" "),e("p",[t._v("跨域：不同源之间的请求，会导致跨域。")]),t._v(" "),e("p",[t._v("跨域存在的意义：为了安全")]),t._v(" "),e("p",[t._v("跨域解决方案：")]),t._v(" "),e("p",[t._v("JSONP：")]),t._v(" "),e("ul",[e("li",[t._v("通过"),e("code",[t._v("script")]),t._v("标签")]),t._v(" "),e("li",[t._v("只支持"),e("code",[t._v("get")]),t._v("接口")]),t._v(" "),e("li",[t._v("访问地址后带上前端定义的callback")]),t._v(" "),e("li",[t._v("需要后端配合")]),t._v(" "),e("li",[t._v("不安全，可能会造成XSS攻击")])]),t._v(" "),e("p",[t._v("CROS：")]),t._v(" "),e("ul",[e("li",[t._v("后端响应头添加上 "),e("code",[t._v("Access-Control-Allow-Origin")])]),t._v(" "),e("li",[t._v("CROS 跨域时，要区分简单请求和非简单请求，对于非简单请求，会先发送一个OPTIONS预检请求，告诉服务期请求方法和自定义请求头\n"),e("ul",[e("li",[t._v("简单请求：GET，HEAD，POST（contentType为"),e("code",[t._v("text/plain")]),t._v(","),e("code",[t._v("multipart/form-data")]),t._v(","),e("code",[t._v("application/x-www-form-urlencode")]),t._v("）")])])])]),t._v(" "),e("p",[t._v("postMessage：")]),t._v(" "),e("ul",[e("li",[t._v("两多个打开的页面之间相互传递消息")])]),t._v(" "),e("p",[t._v("代理：")]),t._v(" "),e("p",[t._v("WebSocket：")]),t._v(" "),e("blockquote",[e("p",[t._v("Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。")])]),t._v(" "),e("p",[t._v("document.domain：")]),t._v(" "),e("blockquote",[e("p",[t._v("只适用于二级域名一样的情况，主页面和iframe之间，document.domain = '一级域名'")])]),t._v(" "),e("h4",{attrs:{id:"关于对原型链的了解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于对原型链的了解"}},[t._v("#")]),t._v(" 关于对原型链的了解")]),t._v(" "),e("p",[t._v("JS中所有函数都可以是构造函数。")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Person")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'123'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" person1 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nperson1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype\n\n"),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype\n\nPerson"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype\n\nFunction"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype\n\n"),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__ "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n")])])]),e("h4",{attrs:{id:"什么是高阶函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是高阶函数"}},[t._v("#")]),t._v(" 什么是高阶函数")]),t._v(" "),e("p",[t._v("在JS中，一个函数可以作为另一个函数的参数或返回值。")]),t._v(" "),e("h4",{attrs:{id:"websocket"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" websocket")]),t._v(" "),e("p",[t._v("Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。")]),t._v(" "),e("h4",{attrs:{id:"promise-generator-async和await-作用及原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-generator-async和await-作用及原理"}},[t._v("#")]),t._v(" Promise, Generator, Async和await 作用及原理")]),t._v(" "),e("p",[t._v("异步解决方案：")]),t._v(" "),e("p",[t._v("Promise")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 实现promise")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// const PENDING = 'pending'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// const FULFILLED = 'fulfilled'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// const REJECTED = 'rejected'")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function resolvePromise() {")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// }")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// class MyPromise {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   constructor(fn) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     if (typeof fn !== 'function') {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       throw new Error('MyPromise must accept a function as a parameter')")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     }")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     this.status = PENDING")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     this.value = null")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     this.fulfilledQueue = []")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     this.rejectedQueue = []")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     try {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       fn(this._resolve.bind(this), this._reject.bind(this))")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     } catch (err) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       this._reject(err)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     }")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   }")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   _resolve(value) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     if (this.status === PENDING) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       this.value = value")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       this.status = RESOLVED")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       this.fulfilledQueue.forEach(callback => {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//         callback(this.value)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       })")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     }")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   }")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   _reject(error) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     if (this.status === PENDING) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       this.value = error")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       this.status = REJECTED")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       this.rejectedQueue.forEach(callback => {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//         callback(this.value)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       })")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     }")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   }")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   then(onFulfilled, onRejected) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : () => {}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     onRejected = typeof onRejected === 'function' ? onRejected : () => {}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     const promise = new MyPromise((resolve, reject) => {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       if (this.status === PENDING) {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//         this.fulfilledQueue.push()")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       }")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       if (this.status === FULFILLED) {")]),t._v("\n        \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       }")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       if (this.status === REJECTED) {")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       }")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     })")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     return promise")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   }")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   catch() {}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// }")]),t._v("\n")])])]),e("h4",{attrs:{id:"重排重绘机制-浏览器重排重绘是-css-样式改变了就马上更新吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重排重绘机制-浏览器重排重绘是-css-样式改变了就马上更新吗"}},[t._v("#")]),t._v(" 重排重绘机制, 浏览器重排重绘是 css 样式改变了就马上更新吗")]),t._v(" "),e("p",[t._v("重排：改变了dom的大小，位置，影响到布局，resize")]),t._v(" "),e("p",[t._v("重绘：只改变了dom的颜色，背景，不影响布局")]),t._v(" "),e("p",[t._v("浏览器是60hz的刷新率，即 1000 / 60 = 16.6，所以是16.6ms更新一次")]),t._v(" "),e("h4",{attrs:{id:"从url输入到页面展示-经历了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从url输入到页面展示-经历了什么"}},[t._v("#")]),t._v(" 从url输入到页面展示，经历了什么？")]),t._v(" "),e("ul",[e("li",[t._v("DNS解析：")]),t._v(" "),e("li",[t._v("HTTP 下载资源")]),t._v(" "),e("li",[t._v("解析DOM，CSSOM，render Object")])]),t._v(" "),e("h4",{attrs:{id:"前端攻击-如何模拟一个csrf-攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端攻击-如何模拟一个csrf-攻击"}},[t._v("#")]),t._v(" 前端攻击, 如何模拟一个CSRF 攻击")]),t._v(" "),e("ul",[e("li",[t._v("XSS")]),t._v(" "),e("li",[t._v("CSRF")])]),t._v(" "),e("h4",{attrs:{id:"前端加密有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端加密有哪些"}},[t._v("#")]),t._v(" 前端加密有哪些")]),t._v(" "),e("h4",{attrs:{id:"http-1-x-2-x-3-x-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-x-2-x-3-x-区别"}},[t._v("#")]),t._v(" http 1.x 2.x 3.x 区别")]),t._v(" "),e("h4",{attrs:{id:"浏览器缓存过程是怎么样的-属性有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存过程是怎么样的-属性有哪些"}},[t._v("#")]),t._v(" 浏览器缓存过程是怎么样的, 属性有哪些")]),t._v(" "),e("ul",[e("li",[t._v("强缓存：Expires，Cache-Control")]),t._v(" "),e("li",[t._v("协商缓存：Last-Modified / IF-Modified-Since，ETag / IF-None-Match")])]),t._v(" "),e("h4",{attrs:{id:"垃圾回收机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[t._v("#")]),t._v(" 垃圾回收机制")]),t._v(" "),e("ul",[e("li",[t._v("标记清除")]),t._v(" "),e("li",[t._v("引用计数")])]),t._v(" "),e("h4",{attrs:{id:"深拷贝的实现-如何避免循环引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝的实现-如何避免循环引用"}},[t._v("#")]),t._v(" 深拷贝的实现？如何避免循环引用？")]),t._v(" "),e("h3",{attrs:{id:"webpack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[t._v("#")]),t._v(" Webpack")]),t._v(" "),e("h4",{attrs:{id:"loader-和-plugin-的不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loader-和-plugin-的不同"}},[t._v("#")]),t._v(" Loader 和 Plugin 的不同")]),t._v(" "),e("h4",{attrs:{id:"_3-x-4-x-和-5-x-有哪些区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-4-x-和-5-x-有哪些区别"}},[t._v("#")]),t._v(" 3.x , 4.x 和 5.x 有哪些区别")]),t._v(" "),e("h4",{attrs:{id:"用过哪些loader-和-plugin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用过哪些loader-和-plugin"}},[t._v("#")]),t._v(" 用过哪些loader 和 Plugin")]),t._v(" "),e("p",[t._v("1.Webpack 的工作过程\n校验配置文件 ：读取命令行传入或者webpack.config.js文件，初始化本次构建的配置参数\n生成Compiler对象：执行配置文件中的插件实例化语句new MyWebpackPlugin()，为webpack事件流挂上自定义hooks\n进入entryOption阶段：webpack开始读取配置的Entries，递归遍历所有的入口文件\nrun/watch：如果运行在watch模式则执行watch方法，否则执行run方法\ncompilation：创建Compilation对象回调compilation相关钩子，依次进入每一个入口文件(entry)，使用loader对文件进行编译。通过compilation我可以可以读取到module的resource（资源路径）、loaders（使用的loader）等信息。再将编译好的文件内容使用acorn解析生成AST静态语法树。然后递归、重复的执行这个过程， 所有模块和和依赖分析完成后，执行 compilation 的 seal 方法对每个 chunk 进行整理、优化、封装__webpack_require__来模拟模块化操作.\nemit：所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的compilation.assets上拿到所需数据，其中包括即将输出的资源、代码块Chunk等等信息。\n2.热更新原理\n3.项目有没配置过Webpack的优化\n4.loader 的工作原理: 本质就是一个个的函数，在模块的编译阶段，会使用这些loader对源代码进行处理，处理时，一般都会生成AST解析树，这样可以方便处理\n5.plugin 的工作原理:\n读取配置的过程中会先执行 new HelloPlugin(options) 初始化一个 HelloPlugin 获得其实例。\n初始化 compiler 对象后调用 HelloPlugin.apply(compiler) 给插件实例传入 compiler 对象。\n插件实例在获取到 compiler 对象后，就可以通过compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack\n6.vite 是什么, 和Webpack有什么区别")]),t._v(" "),e("h3",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),e("h4",{attrs:{id:"vue-2-x-组件通讯的方式-14种"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-x-组件通讯的方式-14种"}},[t._v("#")]),t._v(" Vue 2.X 组件通讯的方式(14种)")]),t._v(" "),e("h4",{attrs:{id:"vue-router-钩子有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-钩子有哪些"}},[t._v("#")]),t._v(" Vue-router 钩子有哪些")]),t._v(" "),e("h4",{attrs:{id:"指令钩子有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#指令钩子有哪些"}},[t._v("#")]),t._v(" 指令钩子有哪些")]),t._v(" "),e("h4",{attrs:{id:"watch和computed区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch和computed区别"}},[t._v("#")]),t._v(" watch和computed区别")]),t._v(" "),e("h4",{attrs:{id:"渲染列表的时候为什么要使用key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染列表的时候为什么要使用key"}},[t._v("#")]),t._v(" 渲染列表的时候为什么要使用key")]),t._v(" "),e("h4",{attrs:{id:"父子组件之间的生命周期执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父子组件之间的生命周期执行顺序"}},[t._v("#")]),t._v(" 父子组件之间的生命周期执行顺序")]),t._v(" "),e("p",[t._v("父beforeCreate，父created，子beforeCreate，子created，子beforeMount，子mounted，父beforeMount，父mounted")]),t._v(" "),e("h4",{attrs:{id:"简单介绍下插槽"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单介绍下插槽"}},[t._v("#")]),t._v(" 简单介绍下插槽")]),t._v(" "),e("p",[t._v("插槽就是vue组件中预留的一部分内容，由外部外传入进来\n指令插槽，作用域插槽")]),t._v(" "),e("h4",{attrs:{id:"什么是路由懒加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是路由懒加载"}},[t._v("#")]),t._v(" 什么是路由懒加载")]),t._v(" "),e("p",[t._v("声明路由时，component的可以是对应一个组件，也可以是一个函数，这个的返回值，是通过require，resolve，import的方式动态加载组件\n作用：是什么？")]),t._v(" "),e("h4",{attrs:{id:"route和router的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#route和router的区别"}},[t._v("#")]),t._v(" route和router的区别")]),t._v(" "),e("p",[t._v("Router是整个项目的路由对象，route是每个页面的路由实例")]),t._v(" "),e("h4",{attrs:{id:"vuex中的action和mutation有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex中的action和mutation有什么区别"}},[t._v("#")]),t._v(" vuex中的action和mutation有什么区别")]),t._v(" "),e("p",[t._v("mutation 是纯函数，接收state，返回state\nAction 主要用来做异步操作，然后有结果后再更新mutation")]),t._v(" "),e("h4",{attrs:{id:"vue创建组件的时候data设计为函数形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue创建组件的时候data设计为函数形式"}},[t._v("#")]),t._v(" vue创建组件的时候data设计为函数形式")]),t._v(" "),e("p",[t._v("如果data是对象，且有多个组件实例，组件实例中改变了data数据，会影响到其他组件实例的data数据")]),t._v(" "),e("h4",{attrs:{id:"vue-的双向数据绑定原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-的双向数据绑定原理"}},[t._v("#")]),t._v(" vue 的双向数据绑定原理")]),t._v(" "),e("p",[t._v("大头头大")]),t._v(" "),e("h4",{attrs:{id:"页面刷新后vuex中的state数据丢失会怎么解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页面刷新后vuex中的state数据丢失会怎么解决"}},[t._v("#")]),t._v(" 页面刷新后vuex中的state数据丢失会怎么解决")]),t._v(" "),e("p",[t._v("Vue 2.x 源码编译的过程\nVue 的diff 过程\n虚拟dom实现原理，为什么要引入虚拟dom？\nVue 的 nextTick 原理\nVue 的set 原理\nVue-router 的实现原理和缓存策略\nvue3新特性\n四、React\nreact 单向数据过程\nreact与vue的异同\nreact新定义的有哪些生命周期\nreact16 的 fiber 理解\nredux工作流程\nredux 为什么要把 reducer 设计成纯函数\nreact 的diff 过程\n什么是高阶组件，如何设计一个高阶组件？")]),t._v(" "),e("h3",{attrs:{id:"react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),e("h4",{attrs:{id:"setstate是同步还是异步-什么时候表现同步-什么时候表现异步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setstate是同步还是异步-什么时候表现同步-什么时候表现异步"}},[t._v("#")]),t._v(" setState是同步还是异步？什么时候表现同步，什么时候表现异步？")]),t._v(" "),e("p",[t._v("好像是生命周期内是异步的，生命周期外是同步的")]),t._v(" "),e("h4",{attrs:{id:"受控组件和非受控组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#受控组件和非受控组件"}},[t._v("#")]),t._v(" 受控组件和非受控组件")]),t._v(" "),e("p",[t._v("受控组件：组件中会改变数据，如表单相关的组件\n非受控组件：组件是纯显示组件，组件的改变都是由外部数据决定的")]),t._v(" "),e("h4",{attrs:{id:"组件通讯方式-13种"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件通讯方式-13种"}},[t._v("#")]),t._v(" 组件通讯方式(13种)")]),t._v(" "),e("h4",{attrs:{id:"decorator-用过没得-作用是啥"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#decorator-用过没得-作用是啥"}},[t._v("#")]),t._v(" Decorator 用过没得, 作用是啥")]),t._v(" "),e("p",[t._v("注解")]),t._v(" "),e("h4",{attrs:{id:"redux的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux的理解"}},[t._v("#")]),t._v(" redux的理解")]),t._v(" "),e("h4",{attrs:{id:"reducer为什么设计成一个纯函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reducer为什么设计成一个纯函数"}},[t._v("#")]),t._v(" reducer为什么设计成一个纯函数")]),t._v(" "),e("h4",{attrs:{id:"react常用的hooks有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react常用的hooks有哪些"}},[t._v("#")]),t._v(" react常用的hooks有哪些")]),t._v(" "),e("p",[t._v("useState, useEffect, useCallback, useMemo, …")]),t._v(" "),e("h4",{attrs:{id:"usememo与useeffect的差别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usememo与useeffect的差别"}},[t._v("#")]),t._v(" useMemo与useEffect的差别")]),t._v(" "),e("p",[t._v("useMomo 和 useCallback 的差别?")]),t._v(" "),e("h4",{attrs:{id:"hooks是哪个版本出现的-解决了什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hooks是哪个版本出现的-解决了什么问题"}},[t._v("#")]),t._v(" hooks是哪个版本出现的, 解决了什么问题")]),t._v(" "),e("p",[t._v("16.8")]),t._v(" "),e("h3",{attrs:{id:"typescript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[t._v("#")]),t._v(" TypeScript")]),t._v(" "),e("h4",{attrs:{id:"_1-作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-作用"}},[t._v("#")]),t._v(" 1.作用")]),t._v(" "),e("p",[t._v("Ts是js的超集，主要是在js的基础上，添加了类型限制")]),t._v(" "),e("h4",{attrs:{id:"用过ts哪些功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用过ts哪些功能"}},[t._v("#")]),t._v(" 用过TS哪些功能")]),t._v(" "),e("p",[t._v("参数类型，返回值类型，装饰器，interface")]),t._v(" "),e("h4",{attrs:{id:"ts-有哪些内置类型-比js多了void"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts-有哪些内置类型-比js多了void"}},[t._v("#")]),t._v(" TS 有哪些内置类型, 比JS多了Void")]),t._v(" "),e("h4",{attrs:{id:"ts的-接口-和-type-语句有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts的-接口-和-type-语句有什么区别"}},[t._v("#")]),t._v(" TS的“接口”和“type”语句有什么区别？")]),t._v(" "),e("h4",{attrs:{id:"typescript中的装饰器作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typescript中的装饰器作用"}},[t._v("#")]),t._v(" TypeScript中的装饰器作用")]),t._v(" "),e("h4",{attrs:{id:"如何检查typescript中的null和undefined"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何检查typescript中的null和undefined"}},[t._v("#")]),t._v(" 如何检查TypeScript中的null和undefined")]),t._v(" "),e("h4",{attrs:{id:"typescript中的泛型作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typescript中的泛型作用"}},[t._v("#")]),t._v(" TypeScript中的泛型作用")]),t._v(" "),e("h4",{attrs:{id:"什么叫函数重载-ts-有函数重载吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么叫函数重载-ts-有函数重载吗"}},[t._v("#")]),t._v(" 什么叫函数重载, TS 有函数重载吗")]),t._v(" "),e("h4",{attrs:{id:"ts-如何在函数中支持可选参数的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts-如何在函数中支持可选参数的"}},[t._v("#")]),t._v(" TS 如何在函数中支持可选参数的")]),t._v(" "),e("h3",{attrs:{id:"编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编程"}},[t._v("#")]),t._v(" 编程")]),t._v(" "),e("h4",{attrs:{id:"位运算实现两个变量相加"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#位运算实现两个变量相加"}},[t._v("#")]),t._v(" 位运算实现两个变量相加")]),t._v(" "),e("h4",{attrs:{id:"实现数组的map方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现数组的map方法"}},[t._v("#")]),t._v(" 实现数组的map方法")]),t._v(" "),e("h4",{attrs:{id:"实现对象数组的去重"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现对象数组的去重"}},[t._v("#")]),t._v(" 实现对象数组的去重")]),t._v(" "),e("h3",{attrs:{id:"node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[t._v("#")]),t._v(" Node")]),t._v(" "),e("h4",{attrs:{id:"用过node-哪些功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用过node-哪些功能"}},[t._v("#")]),t._v(" 用过Node 哪些功能")]),t._v(" "),e("h4",{attrs:{id:"npm和node-的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#npm和node-的关系"}},[t._v("#")]),t._v(" Npm和Node 的关系")]),t._v(" "),e("h3",{attrs:{id:"设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),e("p",[t._v("观察者模式\n发布者订阅模式\n工厂模式\n单例模式\n适配器模式\n策略模式\n中介者模式")]),t._v(" "),e("p",[t._v("六  编程\n实现eventEmmiter类\n（柯里化函数）实现add函数，满足add(1)(2, 3)计算\n实现两个大数相加\n实现节流函数和防抖函数\n实现promise.all、promise.race\n项目中用过哪些设计模式\n如何优化项目")]),t._v(" "),e("p",[t._v("七、Node")]),t._v(" "),e("ol",[e("li",[t._v("require的模块查找规则:\n每个模块里面的exports, require, module, __filename, __dirname五个参数都不是全局变量，而是模块加载的时候注入的。\n为了注入这几个变量，我们需要将用户的代码用一个函数包裹起来，拼一个字符串然后调用沙盒模块vm来实现。\n初始状态下，模块里面的this, exports, module.exports都指向同一个对象，如果你对他们重新赋值，这种连接就断了。\n对module.exports的重新赋值会作为模块的导出内容，但是你对exports的重新赋值并不能改变模块导出内容，只是改变了exports这个变量而已，因为模块始终是module，导出内容是module.exports。\n为了解决循环引用，模块在加载前就会被加入缓存，下次再加载会直接返回缓存，如果这时候模块还没加载完，你可能拿到未完成的exports。\n2.node 事件循环和浏览器的区别\n3.node 中怎么加载 HTML文件\n4.node 怎么解决跨域\n5.koa 原理\n6.node 怎么创建线程, 线程怎么通讯\n7.module.exports与exports的区别\n8.require和import有什么区别, 加载上有什么区别\n9.sql 语句有了解吗\n10.npm提供了哪些钩子？各有什么作用\n11.mySql 和 mongonDB 区别")])])])}),[],!1,null,null,null);a.default=r.exports}}]);